<!DOCTYPE html>
<html>
<head>
<title>fido_operation_process</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<style type="text/css">
/* GitHub stylesheet for MarkdownPad (http://markdownpad.com) */
/* Author: Nicolas Hery - http://nicolashery.com */
/* Version: b13fe65ca28d2e568c6ed5d7f06581183df8f2ff */
/* Source: https://github.com/nicolahery/markdownpad-github */

/* RESET
=============================================================================*/

html, body, div, span, applet, object, iframe, h1, h2, h3, h4, h5, h6, p, blockquote, pre, a, abbr, acronym, address, big, cite, code, del, dfn, em, img, ins, kbd, q, s, samp, small, strike, strong, sub, sup, tt, var, b, u, i, center, dl, dt, dd, ol, ul, li, fieldset, form, label, legend, table, caption, tbody, tfoot, thead, tr, th, td, article, aside, canvas, details, embed, figure, figcaption, footer, header, hgroup, menu, nav, output, ruby, section, summary, time, mark, audio, video {
  margin: 0;
  padding: 0;
  border: 0;
}

/* BODY
=============================================================================*/

body {
  font-family: Helvetica, arial, freesans, clean, sans-serif;
  font-size: 14px;
  line-height: 1.6;
  color: #333;
  background-color: #fff;
  padding: 20px;
  max-width: 960px;
  margin: 0 auto;
}

body>*:first-child {
  margin-top: 0 !important;
}

body>*:last-child {
  margin-bottom: 0 !important;
}

/* BLOCKS
=============================================================================*/

p, blockquote, ul, ol, dl, table, pre {
  margin: 15px 0;
}

/* HEADERS
=============================================================================*/

h1, h2, h3, h4, h5, h6 {
  margin: 20px 0 10px;
  padding: 0;
  font-weight: bold;
  -webkit-font-smoothing: antialiased;
}

h1 tt, h1 code, h2 tt, h2 code, h3 tt, h3 code, h4 tt, h4 code, h5 tt, h5 code, h6 tt, h6 code {
  font-size: inherit;
}

h1 {
  font-size: 28px;
  color: #000;
}

h2 {
  font-size: 24px;
  border-bottom: 1px solid #ccc;
  color: #000;
}

h3 {
  font-size: 18px;
}

h4 {
  font-size: 16px;
}

h5 {
  font-size: 14px;
}

h6 {
  color: #777;
  font-size: 14px;
}

body>h2:first-child, body>h1:first-child, body>h1:first-child+h2, body>h3:first-child, body>h4:first-child, body>h5:first-child, body>h6:first-child {
  margin-top: 0;
  padding-top: 0;
}

a:first-child h1, a:first-child h2, a:first-child h3, a:first-child h4, a:first-child h5, a:first-child h6 {
  margin-top: 0;
  padding-top: 0;
}

h1+p, h2+p, h3+p, h4+p, h5+p, h6+p {
  margin-top: 10px;
}

/* LINKS
=============================================================================*/

a {
  color: #4183C4;
  text-decoration: none;
}

a:hover {
  text-decoration: underline;
}

/* LISTS
=============================================================================*/

ul, ol {
  padding-left: 30px;
}

ul li > :first-child, 
ol li > :first-child, 
ul li ul:first-of-type, 
ol li ol:first-of-type, 
ul li ol:first-of-type, 
ol li ul:first-of-type {
  margin-top: 0px;
}

ul ul, ul ol, ol ol, ol ul {
  margin-bottom: 0;
}

dl {
  padding: 0;
}

dl dt {
  font-size: 14px;
  font-weight: bold;
  font-style: italic;
  padding: 0;
  margin: 15px 0 5px;
}

dl dt:first-child {
  padding: 0;
}

dl dt>:first-child {
  margin-top: 0px;
}

dl dt>:last-child {
  margin-bottom: 0px;
}

dl dd {
  margin: 0 0 15px;
  padding: 0 15px;
}

dl dd>:first-child {
  margin-top: 0px;
}

dl dd>:last-child {
  margin-bottom: 0px;
}

/* CODE
=============================================================================*/

pre, code, tt {
  font-size: 12px;
  font-family: Consolas, "Liberation Mono", Courier, monospace;
}

code, tt {
  margin: 0 0px;
  padding: 0px 0px;
  white-space: nowrap;
  border: 1px solid #eaeaea;
  background-color: #f8f8f8;
  border-radius: 3px;
}

pre>code {
  margin: 0;
  padding: 0;
  white-space: pre;
  border: none;
  background: transparent;
}

pre {
  background-color: #f8f8f8;
  border: 1px solid #ccc;
  font-size: 13px;
  line-height: 19px;
  overflow: auto;
  padding: 6px 10px;
  border-radius: 3px;
}

pre code, pre tt {
  background-color: transparent;
  border: none;
}

kbd {
    -moz-border-bottom-colors: none;
    -moz-border-left-colors: none;
    -moz-border-right-colors: none;
    -moz-border-top-colors: none;
    background-color: #DDDDDD;
    background-image: linear-gradient(#F1F1F1, #DDDDDD);
    background-repeat: repeat-x;
    border-color: #DDDDDD #CCCCCC #CCCCCC #DDDDDD;
    border-image: none;
    border-radius: 2px 2px 2px 2px;
    border-style: solid;
    border-width: 1px;
    font-family: "Helvetica Neue",Helvetica,Arial,sans-serif;
    line-height: 10px;
    padding: 1px 4px;
}

/* QUOTES
=============================================================================*/

blockquote {
  border-left: 4px solid #DDD;
  padding: 0 15px;
  color: #777;
}

blockquote>:first-child {
  margin-top: 0px;
}

blockquote>:last-child {
  margin-bottom: 0px;
}

/* HORIZONTAL RULES
=============================================================================*/

hr {
  clear: both;
  margin: 15px 0;
  height: 0px;
  overflow: hidden;
  border: none;
  background: transparent;
  border-bottom: 4px solid #ddd;
  padding: 0;
}

/* TABLES
=============================================================================*/

table th {
  font-weight: bold;
}

table th, table td {
  border: 1px solid #ccc;
  padding: 6px 13px;
}

table tr {
  border-top: 1px solid #ccc;
  background-color: #fff;
}

table tr:nth-child(2n) {
  background-color: #f8f8f8;
}

/* IMAGES
=============================================================================*/

img {
  max-width: 100%
}
</style>
</head>
<body>
<h1>fido 操作流程阐述</h1>
<ol>
<li>
<h2><a href="#1.1">GetInfo操作</a></h2>
<ol>
<li><a href="#1.1">GetInfo操作的目的</a></li>
<li>
<a href="#1.2">GetInfo操作具体步骤程以及数据演变</a>
<ul>
<li><a href="#1.2.1">1.Fido Client</a></li>
<li><a href="#1.2.2">2.ASM</a></li>
<li><a href="#1.2.3">3.认证器</a></li>
<li><a href="#1.2.4">4.ASM</a></li>
<li><a href="#1.2.5">5.Fido Client</a></li>
</ul>
</li>
</ol>
</li>
<li>
<h2><a href="#2.1">Register操作</a></h2>
<ol>
<li><a href="#2.1">Register操作的目的</a></li>
<li>
<a href="#2.2">Register操作具体流程以及数据演变</a>
<ul>
<li><a href="#2.2.1">1.Fido Client</a></li>
<li><a href="#2.2.2">2.Fido Server</a></li>
<li><a href="#2.2.3">3.Fido Client</a></li>
<li><a href="#2.2.4">4.ASM</a></li>
<li><a href="#2.2.5">5.认证器</a></li>
<li><a href="#2.2.6">6.ASM</a></li>
<li><a href="#2.2.7">7.Fido Client</a></li>
<li><a href="#2.2.8">8.Fido Server</a></li>
</ul>
</li>
</ol>
</li>
<li>
<h2><a href="#3.1">Authenticate 操作流程</a></h2>
<ol>
<li><a href="#3.1">Authenticate操作的目的</a> </li>
<li>
<a href="#3.2">Authenticate操作具体流程以及数据演变</a>
<ul>
<li><a href="#3.2.1">1.Fido Client</a></li>
<li><a href="#3.2.2">2.Fido Server</a></li>
<li><a href="#3.2.3">3.Fido Client</a></li>
<li><a href="#3.2.4">4.ASM</a></li>
<li><a href="#3.2.5">5.认证器</a></li>
<li><a href="#3.2.6">6.ASM</a></li>
<li><a href="#3.2.7">7.Fido Client</a></li>
<li><a href="#3.2.8">8.Fido Server</a></li>
</ul>
</li>
</ol>
</li>
</ol>
<h2 id="1.1">1.GetInfo操作</h2>
<h3 id="1.1">1.1 GetInfo操作的目的</h3><p>GetInfo操作的目的是为了获取认证器的详细信息，为什么要获取认证器的详细信息呢？因为一个设备上，可能集成了很多个认证器（比如指纹认证器，声音认证器，虹膜认证器等），这时候，用户一次只能使用一种认证器来进行fido认证，那么，FidoClient需要根据服务器的policy来决定使用哪种认证器，继而在之后数据传递操作中，告诉ASM选择哪种认证器做后续的操作流程。</p>
<p>Fido Client: FidoClient每次在收到fidoServer的Request的信息之后，都会解析policy字段，具体操作流程如下所示：<img src="5.1.1.png" /></br>我们可以看到，Fido Client会根据服务器的policy和获取本地认证器的信息来进行后续的步骤</p>
<h3 id="1.2">1.2 GetInfo操作具体步骤程以及数据演变的</h3>
<ol>
<li><h5 id="1.2.1">Fido Client:</h5>首先FidoClient收到服务器的消息后，向 ASM发出获取Info的请求，这个请求体的格式为：</br><img src="5.1.2.png" /></li>
<li>
<h5 id="1.2.2">ASM:</h5>ASM收到请求消息后，做如下操作：
<ul>
<li>1.首先列举出在该设备上且ASM支持的认证器</li>
<li>2.向所有的认证器发送GetInfo指令</li>
<li>向ASM发送信息的结构截图所示：<img src="5.1.3.png" /></li>
</ul>
</li>
<li><h5 id="1.2.3">认证器:</h5>认证器收到GetInfo的请求后，生成GetInfo返回体，然后把认证器的详细信息返回给ASM</li>
<li><h5 id="1.2.4">ASM:</h5>ASM收到信息后，基本不做过多处理，简单组织信息后，直接返回给FidoClient,返回的信息体如下<img src="5.1.5.png" /></li>
<li><h5 id="1.2.5">Fido Client:</h5>Fido Client收到信息之后，会将服务器的policy中的信息和认证器信息进行匹配，找到匹配成功的认证器后，将authenticatorIndex加入请求ASM的消息体中。</li>
</ol>
<h2 id="2.1">2.Register操作</h2>
<h3 id="2.1">2.1 Register操作</h3><p>注册操作主要是为用户的认证操作做准备。在注册操作中，认证器会生成之后认证过程最关键的公私钥对，KeyHandle，KeyId等重要数据，为之后的认证过程能够认证用户身份做数据铺垫。</p>
<p><h3 id="2.2">2.2 Register操作具体流程以及数据演变
     1. <h5 id="2.2.1">1.Fido Client:</h5> fidoClient首先会发送如下图的信息给Fido Server：<img src="5.1.6.png" />
     2. <h5 id="2.2.2">2.Fido Server</h5>Fido Sever收到请求后，组织如下数据信息，发送给Fido Client（注：由于本篇文档是主要阐述关于客户端的，因此，服务器如何组织信息，客户端这里不做解释）<img src="5.1.7.png" /></br>我们可以看到，服务器的信息包含：header[upv,severData,op],policy[accpted,disallow],AppId,challenge的信息.
     3. <h5 id="2.2.3">3.Fido Client</h5> FidoClient 收到第2步的信息后，做如下操作:</p>
<ul>
<li>1.用json解析upv中的major version和minor versionn是否1，0；</li>
<li>2.用json解析服务器发送的全部信息</li>
<li>
3.根据消息中的policy字段来筛选符合的认证器：具体的筛选步骤如下：
<ul>
<li>解析policy里面的信息（policy里面的信息都是FidoServer认可的，用户可以注册的认证器）</li>
<li>根据最近较常使用的认证器来选择policy信息里面的组合</li>
<li>搜集所有可用的认证器信息</li>
<li>排除policy.disallowed的信息</li>
<li>找到匹配policy.accepted中包含的认证器</li>
<li>引导用户使用匹配成功的认证器（让用户选择匹配成功的认证器）</li>
</ul>
</li>
<li>
4.根据AppID来获取FacetId，具体的操作如下：
<ul>
<li>1.</li>
<li>2.</li>
<li>3.</li>
</ul>
</li>
<li>5.形成FinalCallengeParams的内容，FinalCallengeParams就是appID 和challenge,facetIdf的json字符串的信息(Base64b编码形成的)</li>
<li>6.形成下图所示的信息，发送请求信息，发送给ASM：<img src="5.1.8.png" /></br>我们可以看到，包含的信息包括（认证器索引信息，操作类型，ASM版本号，请求参数[finalChallege,appID,userName]）</li>
</ul>
<h5 id="2.2.4">4.ASM</h5>
<p>ASM收到请求的信息体后，做如下的操作：</p>
<ol>
<li>根据authenticatorIndex找到对应的认证器，如果索引值没有找到对应的认证器，则返回错误的状态码</li>
<li>
<p>如果认证器中已经有用户的身份特征信息了，则要求要求认证器验证用户的身份，并且生成UserVerificationToken字段（如果认证器支持这个字段的话）；如果认证器验证用户身份失败，则返回拒绝的状态代码。</p>
</li>
<li>
<p>如果认证器中并未含有用户的身份特征信息，则要求认证器现在录入用户身份特征信息</p>
</li>
<li>
生成KeyHandleAccessToken的数值
<ul>
<li>1.KeyAccessToken=AppID</li>
<li>2.如果为绑定类的认证器则：KHAccessToken |= ASMToken | PersonaID | CallerID(注：其中，ASMToken是ASM的一个特征数值，PersonID是操作系统用户名，CallerID是调用FidoClient的APP的包名)</li>
<li>3.计算KHAccessToken的hash数值，摘要算法是认证器内部的摘要算法:KHAccessToken=hash(KHAccessToken)</li>
</ul>
</li>
<li>计算FinalChanllege的摘要数值（hash算法应该用认证器自己的hash算法）</li>
<li>生成如下图信息（TLV格式）发送给认证器：<img src="5.1.10.png" />
  可以看到上图的信息包括（认证器索引值，APPID，挑战的摘要值，注册的用户名，认证器的认证方式，KHAceesToken）</li>
</ol>
<h5 id="2.2.5">5.认证器</h5> <p>认证器收到ASM的请求体之后，做如下操作： </p>
<ol>
<li>
<p>如果APPID的字段不为空，则再次更新KeyAceessToken的数值 KHAccessToken=hash(KHAccessToken | Command.TAG_APPID)</p>
</li>
<li>
<p>如果认证器中已经含有了用户的身份特征信息（比如用户的指纹，声音等类型的信息），验证用户的身份的合法性。如果TAG<em>USERVERIFY</em>TOKEN字段不为空，则验证TAG<em>USERVERIFY</em>TOKEN字段的合法性；如果认证失败，则返回拒绝的响应状态码。  
</p>
</li>
<li>如果认证器中没有没用用户的信息，则当场让认证器记录用户的身份特征信息，如果用户取消记录，则返回取消的状态码，如果记录失败，则返回拒绝的状态代码。</li>
<li>确保TAG<em>ATTESTATION</em>TYPE 是认证器支持的类型，否则返回不支持的响应的代码</li>
<li>以上操作都没有问题之后，产生一个密钥对(公私钥)</li>
<li>
生成RawKeyHandle:
<ul>
<li>.将私钥加入RawKeyHandle对象</li>
<li>.将TAG<em>KEYHANDLE</em>ACCESS_TOKEN 加入RawKeyHandle对象</li>
<li>.如果是第一类认证器，KeyHandle还要加入用户名字</li>
</ul>
</li>
<li>对RawKeyHandle进行加密(加密方式由认证器决定）(AES加密算法)</li>
<li>形成KRD的内容：（以TLV的形式）KRD的内容如下图所示：<img src="5.1.11.png" /></br>KRD[AAID,ASSERTION<em>INFO,FINAL</em>CHALLENGE,KEY_ID,COUNTERS,PUBLIC KEY]（注：如果是二因子非绑定类型的认证器，则用KeyHandle代替KeyId）</li>
<li>按照协议规范组织KRD的内容</li>
<li>
生成签名证书TAG<em>AUTHENTICATOR</em>ASSERTION的内容：
<ul>
<li>生成KRD的摘要信息，并且用私钥对KRD进行签名。</li>
<li>如果是第一类认证器，则会把keyHandle发给ASM保存，如果是二因子的认证器，则要直接把username和keyHanlde保存在认证器内部</li>
<li>加入X509的证书信息</li>
<li>按照TLV的形式组织TAG<em>AUTHENTICATOR</em>ASSERTION的内容</li>
</ul>
</li>
<li>将KRD和TAG<em>AUTHkeENTICATOR</em>ASSERTION按照TLV的形式返回给ASM，数据信息如下：<img src="5.1.12.png" /></li>
</ol>
<h5 id="2.2.6">6.ASM</h5><p>ASM收到认证返回的信息之后，做如下操作：</p>
<ol>
<li>解析TAG<em>AUTHENTICATOR</em>ASSERTION消息体，提取出KEY_ID的的数值</li>
<li>如果认证器是绑定类型的认证器，则将CallerID,AppID,TAG<em>KEYHANDLE,TAG</em>KEYID,当前系统时间存入ASM的数据库中。</li>
<li>构造向FidoClient向上传递的信息体，如下图所示<img src="5.1.13.png" /></li>
</ol>
<h5 id="2.2.7">7.Fido Client</h5><p>Fido Client收到ASM的返回的消息体之后，做如下处理：</br></p>
<p>构造向FidoServer返回的消息体</p>
<ul>
<li>构造头部信息：就是服务器一开始发过来的头部信息header[upv,severData,op]</li>
<li>从ASM返回的消息体中，提取出FINAL_CHALLENGE的信息，然后加入fcParams 中</li>
<li>将ASM返回的消息体中的ASSERTION加入RegisterOut的内容中</li>
<li>形成如下图所示的消息体：<img src="5.1.14.png" /></li>
<li>将消息体发送给Fido Server</li>
</ul>
<h5 id="2.2.8">8.Fido Sever</h5><p>FidoSever做后续处理，比如存储KeyID，验证签名是否正确等等</p>
<h2 id="3.1">3.Authenticate操作</h2>
<h3 id="3.1">3.1 Authenticate操作的目的</h3><p>认证操作的主要目的是在注册操作已经完成</p>
<h3 id="3.2">3.2 Authenticate操作具体流程以及数据演变</h3><p>认证过程中每一步的操作以及每一层做的具体的事情如下所示</p>
<h5 id="3.2.1">1.Fido Client</h5><p>Fido Client向服务器发送验证的请求，请求内容包含userName。</p>
<h5 id="3.2.2">2.Fido Server</h5><p>Fido Server组织信息如下图所示（由于本文档主要面向客户端，因此server如何组织的信息，这里略去）
   <img src="5.2.2.png" /></br>可以看到，fidosever发送的信息中，含有header[upv,severData,op],challenge,policy[accpeted[keyid,aaid],disallow],其中，keyID和AAID是在注册过程认证器留在服务器上的信息（注：keyID和AAID的组合一定是唯一的）</p>
<h5 id="3.2.3">3.Fido Client</h5><p>FidoClient收到FidoServer的消息后，作如下操作：</p>
<ul>
<li>用json解析信息服务器的报文体</li>
<li>
<p>根据AppID获取到faceID：</p>
<ul>
<li>如果</li>
<li>如果</li>
<li>如果</li>
</ul>
</li>
<li>
<p>根据policy的信息，筛选出符合的认证器:</p>
<ul>
<li>根据经常使用的认证器信息来选择policy.accpted的中的组合信息</li>
<li>搜集所有可用的认证器信息</li>
<li>如果有认证器的信息在policy.disallowed中，则忽略这些信息</li>
<li>根据policy中的信息来匹配认证器的信息</li>
<li></li>
</ul>
</li>
<li>
<p>找到匹配的认证器后，让用户选择用户想使用的认证器(authenticatorIndex)</p>
</li>
<li>形成FinalChallenge的信息，计算方法和注册时候的是一样的。</li>
<li>形成如下图的格式的请求数据，交给ASM.<img src="5.1.8.png" /></li>
</ul>
<h5 id="3.2.4">4.ASM</h5><p>ASM收到信息后，做如下的操作：</p>
<ol>
<li>根据authenticatorIndex找到对应的认证器</li>
<li>如果认证器中没有用户的身份特征信息，则返回拒绝的响应状态码</li>
<li>
<p>ASM要求认证器去检验用户的身份，如果用户的身份检验失败，则返回被拒绝的响应字段</p>
<ul>
<li>如果认证器支持UserVerificationToken这个字段，则将UserVerificationToken这个字段也发给认证器</li>
</ul>
</li>
<li>生成KeyHandleAcessToken的数值，这个计算的方式和注册的时候的一样的（KeyHandleAcessToken主要用于认证器去信任ASM）</li>
<li>用认证器的自己的hash算法计算finalChallegne的摘要</li>
<li>如果是二因子的认证器，发现KeyIDs为空，则返回拒绝的响应字段   </li>
<li>
如果keyIDs不为空（KeyID就是用来寻找KeyHandle的）
<ul>
<li>如果为绑定类型的认证器，则通过AppId，KeyId在ASM的数据库中去查找对应的KeyHandle</li>
<li>如果为非绑定类型的认证器，则将keyID放入KeyHandle的字段中去（远程认证器是在注册时候将keyHanlde存储在内部的）      
</li>
</ul>
</li>
</ol>
<p>8.形成如下的信息格式发送给验证器 <img src="5.1.10.png" /></p>
<h5 id="3.2.5">5.认证器</h5><p>认证器收到请求后，做如下的操作：</p>
<ol>
<li>更新KeyAcessToken的数值（计算方法和注册过程是一样的）</li>
<li>
如果认证器中有用户的身份特征信息（比如指纹，虹膜等）则验证用户的身份是否正确，并且验证UserVerificationToken字段是否有效
<ul>
<li>如果验证失败，则返回拒绝的状态码</li>
<li>如果用户有取消操作的动作，如果有，则返回取消操作的状态码</li>
</ul>
</li>
<li>如果用户没有注册，则返回没有注册的验证信息</li>
<li>用验证器的内部的加密算法（AES算法）解密KeyHandle的数值</li>
<li>用KeyAcessToken的数值来过滤第4步找到的所有的KeyHandle，比较两者的摘要是否一致。RawKeyHandle.KHAccessToken == Command.KHAccessToken主要用于认证器信任消息确实为ASM所发</li>
<li>经过过滤之后，如果KeyHandle的个数为零，则返回拒绝验证的状态码</li>
<li>
如果剩下的KeyHandle的个数的大于1
<ul>
<li>如果为二因子的认证器，则直接挑选第一个keyHnadle然后进入第8步骤</li>
<li>形成{Command.KeyHandle, RawKeyHandle.username}的这样一对对的元组信息，放入TAG<em>USERNAME</em>AND_KEYHANDLEs字段中，然后返回给ASM</li>
</ul>
</li>
<li>
如果剩下的KeyHandle的等于1：
<ul>
<li>
构造ASSERTION的信息
<ul>
<li>形成证书信息（证书信息包括：AAID，CHALLENGE,COUNTERS[引用计数器]等）</li>
<li>用私钥签名证书的信息</li>
</ul>
</li>
<li>形成如下图所示的信息体，然后返回ASM<img src="5.2.7.png" /></li>
</ul>
</li>
</ol>
<h5 id="3.2.6">6.ASM</h5><p>ASM收到认证器返回的消息之后，做如下的操作</p>
<ul>
<li>
1.如果是一因子的认证器，而且 TAG<em>USERNAME</em>AND_KEYHANDLE字段不为空的话：
<ul>
<li>1.从字段中提取出所有的{Command.KeyHandle, RawKeyHandle.username}元组对</li>
<li>2.找到所有元组中是否相同username，如果多个相同，则根据注册阶段在ASM的数据库中的注册时间，挑选一个注册时间最近的username做处理，剩下的username都排除</li>
<li>3.如果剩下的元组的个数都还是大于1，则让用户选择一个username，从而找到一个对应的keyHandle</li>
<li>4.用户选择完成之后，重复<a href="#3.2.4">4.ASM</a>的步骤中的第8步再次请求ASM</li>
</ul>
</li>
<li>2.如果上述条件不满足，则形成如下图所示数据，向FidoClient传递
   <img src="5.2.8.png" />        </li>
</ul>
<h5 id="3.2.7">7.FidoClient</h5><p>FidoClient收到ASM返回的数据后，做如下操作：</p>
<ul>
<li>形成Header的信息(Header信息就是fidosever开始请求的header的信息)</li>
<li>形成将FinalChallenge的信息加入返回消息体中</li>
<li>将ASM的信息也加入返回的消息中</li>
<li>形成如下图所示的消息体:<img src="5.2.9.png" /></li>
<li>发送给fidoserver</li>
</ul>
<h5 id="3.2.8">8.FidoServer</h5><p>FidoSever收到消息后，做签名计数器验证，挑战的签名验证等一系列的工作</p>

</body>
</html>
<!-- This document was created with MarkdownPad, the Markdown editor for Windows (http://markdownpad.com) -->
